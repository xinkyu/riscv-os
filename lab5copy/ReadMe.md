# Lab 6: 系统调用

本实验在 Lab 5 的基础上实现了系统调用机制，使内核能够为用户程序提供服务。

## 实验目标

1. 理解系统调用的工作原理和实现机制
2. 实现用户态和内核态的切换（陷阱处理）
3. 实现系统调用分发器和参数传递
4. 实现基本的系统调用：fork, exit, wait, getpid 等
5. 支持用户进程的创建和运行

## 核心实现

### 1. 系统调用框架
- **syscall.c**: 系统调用分发器，负责根据系统调用号调用相应的处理函数
- **syscall.h**: 定义系统调用号
- **sysproc.c**: 进程相关的系统调用实现
- **sysfile.c**: 文件相关的系统调用实现（简化版）

### 2. 用户态支持
- **trampoline.S**: 用户态和内核态切换的汇编代码
- **trapframe**: 保存用户寄存器状态的结构体
- **usertrap**: 处理来自用户态的陷阱

### 3. 系统调用实现
- **fork**: 创建子进程
- **exit**: 终止进程
- **wait**: 等待子进程退出
- **getpid**: 获取当前进程 ID
- **write**: 输出到控制台（简化版）

### 4. 用户内存管理
- **uvmcopy**: 复制父进程内存到子进程
- **uvmalloc**: 分配用户内存
- **copyout/copyin**: 内核和用户空间之间复制数据

## 编译和运行
```bash
cd lab6
make clean
make run
```

## 测试内容

Lab 6 的测试包括：
- 基本系统调用测试（fork, exit, wait）
- 参数传递测试
- 多进程测试

## 关键技术点

1. **陷阱处理**: 通过 ecall 指令触发系统调用，CPU 切换到 S 模式
2. **参数传递**: 系统调用号通过 a7 寄存器传递，参数通过 a0-a5 传递
3. **返回值**: 系统调用返回值存储在 a0 寄存器中
4. **内存隔离**: 用户进程有独立的页表，与内核内存隔离

## 注意事项

1. 本实现是简化版，主要用于教学目的
2. trampoline 机制简化，直接使用内核陷阱向量
3. 文件系统暂未实现，write 系统调用仅支持控制台输出
4. 用户程序暂时以 initcode 形式硬编码在内核中

## 下一步

Lab 7 将实现文件系统，提供完整的文件操作支持。