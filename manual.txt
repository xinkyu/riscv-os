从零构建操作系统-学生指导手册
总说明
开发环境要求

推荐开发平台：Ubuntu 22.04 LTS（或 WSL2）
 基础工具：git / make / Python3 / qemu-system-riscv64 / riscv64-unknown

elf-gcc

学习方法：理解原理 → 参考xv6 → 独立实现 → 测试调试
 进度要求：每完成一个阶段运行测试并提交代码


核心学习资料

xv6-riscv源码：https://github.com/mit-pdos/xv6-riscv
 RISC-V规范：https://riscv.org/technical/specifications/


 重点：Volume II: Privileged Specification（特权级规范）https://drive.go
ogle.com/file/d/17GeetSnT5wW3xNuAHI95-SI1gPGd5sJ_/view
 在线版本：https://riscv.github.io/riscv-isa-manual/snapshot/privileged/
#_preface


xv6手册：https://pdos.csail.mit.edu/6.828/2025/xv6/book-riscv-rev5.pdf

统一提交要求

每个实验需提交以下内容：
1

1. 源代码仓库 (通过git管理)

2

├── 完整实现代码（带注释）

3

├── Makefile

4

├── README.md (编译运行说明)

5

└── 规范的目录结构

6
7

2. 综合实验报告 (report.md)

8

├── 系统设计部分

9

│

├── 架构设计说明

10

│

├── 关键数据结构

11

│

├── 与xv6对比分析

12

│

└── 设计决策理由

13

├── 实验过程部分

14

│

├── 实现步骤记录

15

│

├── 问题与解决方案

16

│

└── 源码理解总结

17

└── 测试验证部分

18

├── 功能测试结果

19

├── 性能数据

20

├── 异常测试

21

└── 运行截图/录屏

实验0：开发环境搭建
环境搭建步骤
1. 安装基础依赖
1

# Ubuntu/Debian系统

2

sudo apt-get update

3

sudo apt-get install -y build-essential git python3 qemu-system-misc e
xpect gdb-multiarch

4
5

# 验证QEMU版本（建议5.0+）

6

qemu-system-riscv64 --version

2. 安装RISC-V工具链
1

# 方案A：使用预编译包（推荐）

2

wget https://github.com/riscv-collab/riscv-gnu-toolchain/releases/down
load/2023.07.07/riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightl
y.tar.gz

3

sudo tar -xzf riscv64-elf-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.
tar.gz -C /opt/

4

echo 'export PATH="/opt/riscv/bin:$PATH"' >> ~/.bashrc

5

source ~/.bashrc

6
7

# 方案B：包管理器安装（可能版本较旧）

8

sudo apt-get install gcc-riscv64-unknown-elf

9
10

# 验证安装

11

riscv64-unknown-elf-gcc --version

3. 获取参考资料
1

# 克隆xv6源码作为参考

2

git clone https://github.com/mit-pdos/xv6-riscv.git

3

cd xv6-riscv && make qemu

4. 创建项目结构

# 验证能否正常运行

1

mkdir riscv-os && cd riscv-os

2

git init

3

mkdir -p kernel/{boot,mm,trap,proc,fs,net} include scripts

5. 验证环境
创建测试文件验证交叉编译：
1

echo 'int main(){ return 0; }' > test.c

2

riscv64-unknown-elf-gcc -c test.c -o test.o

3

file test.o

# 应显示RISC-V 64-bit

实验1：RISC-V引导与裸机启动
实验目标
通过参考xv6的启动机制，理解并实现最小操作系统的引导过程，最终在QEMU中输
出"Hello OS"。

核心学习资料
xv6关键文件分析


- 启动汇编代码

kernel/entry.S

 重点理解：栈设置、BSS清零、跳转到C代码
 思考：为什么需要设置栈？栈应该多大？


kernel/kernel.ld

- 链接脚本

 重点理解：入口点设置、段的组织、符号定义
 思考：各个段的作用和排列顺序


kernel/uart.c

- 串口驱动

 重点理解：UART寄存器操作、字符输出实现
 思考：如何简化为最小实现？

RISC-V启动机制

特权级规范第3.1节：机器模式启动状态
 QEMU virt平台：内存布局和设备地址


1

# 查看QEMU设备树

2

qemu-system-riscv64 -machine virt,dumpdtb=virt.dtb -nographic

3

dtc -I dtb -O dts virt.dtb | grep -A5 -B5 "uart\|memory"

任务列表

任务1：理解xv6启动流程
学习方法：

1. 阅读 kernel/entry.S ，回答：
 为什么第一条指令是设置栈指针？


la sp, stack0 中的stack0在哪里定义？

 为什么要清零BSS段？
 如何从汇编跳转到C函数？
2. 分析 kernel/kernel.ld ，思考：


ENTRY(_entry) 的作用是什么？

 为什么代码段要放在0x80000000？


etext 、 edata 、 end 符号有什么用途？

深入思考：

 xv6支持多核，你的单核系统可以如何简化？
 xv6的内存管理很复杂，最小系统需要哪些部分？

任务2：设计最小启动流程
设计要求：

1. 绘制你的启动流程图
2. 确定内存布局方案
3. 列出必需的硬件初始化步骤

关键问题：

 栈应该放在内存的哪个位置？需要多大？
 是否需要清零BSS段？为什么？
 最简串口输出需要配置哪些寄存器？

任务3：实现启动汇编代码

参考xv6实现思路，但要大幅简化：
实现步骤：
1. 创建 kernel/entry.S
2. 设置入口点和栈指针
3. 清零BSS段（如果需要）
4. 跳转到C主函数

调试检查点：
1

# 在关键位置插入调试代码

2

_start:

3

li t0, 0x10000000

# UART基地址

4

li t1, 'S'

# 启动标记

5

sb t1, 0(t0)

# 输出字符S表示启动

6
7

# 设置栈后再输出一个字符验证

8

la sp, stack_top

9

li t1, 'P'

10

sb t1, 0(t0)

# 栈设置完成标记

任务4：编写链接脚本

参考xv6的基本结构，简化复杂部分：
设计考虑：
1. 确定起始地址（通常是0x80000000）
2. 组织代码段、数据段、BSS段
3. 定义必要的符号供C代码使用

验证方法：
1

# 编译后检查内存布局

2

riscv64-unknown-elf-objdump -h kernel.elf

3

riscv64-unknown-elf-nm kernel.elf | grep -E "(start|end|text)"

任务5：实现串口驱动

参考xv6的uart.c，实现最小功能：
学习要点：
1. UART 16550的基本寄存器：
 THR (Transmit Holding Register): 0x10000000
 LSR (Line Status Register): 0x10000005
2. 输出一个字符的完整流程
3. 为什么需要检查LSR的THRE位？

实现策略：
1

// 先实现最基本的字符输出

2

void uart_putc(char c);

3
4

// 成功后实现字符串输出

5

void uart_puts(char *s);

调试建议：
 先在汇编中直接写UART验证硬件工作
 再在C函数中实现相同功能
 最后实现完整的字符串输出

任务6：完成C主函数
设计考虑：

 函数名可以不是main，与链接脚本保持一致
 程序结束后应该做什么？死循环还是关机？
 如何防止程序意外退出导致系统重启？

调试策略
分阶段调试法

硬件验证阶段：在汇编中直接写UART
2. 启动验证阶段：验证能跳转到C函数
3. 功能验证阶段：实现完整的Hello输出
1.

常见问题诊断

问题：QEMU启动后无任何输出
 检查链接脚本的起始地址
 验证UART基地址是否正确
 确认程序是否被正确加载

问题：输出乱码或不完整

 检查UART初始化是否充分
 验证字符发送间隔是否太快
 确认字符串是否正确终止

GDB调试技巧
1

# 启动调试环境

2

make qemu-gdb

3

gdb-multiarch kernel/kernel.elf

4

(gdb) target remote :1234

5

(gdb) b _start

6

(gdb) c

7

(gdb) layout asm

8

(gdb) si

# 在一个终端
# 在另一个终端

# 单步执行汇编

思考题
1.

启动栈的设计：

 你如何确定栈的大小？考虑哪些因素？
 如果栈太小会发生什么？如何检测栈溢出？
2.

BSS段清零：

 写一个全局变量，不清零BSS会有什么现象？
 哪些情况下可以省略BSS清零？
3.

与xv6的对比：

 你的实现比xv6简化了哪些部分？
 这些简化在什么情况下会成为问题？
4.

错误处理：

 如果UART初始化失败，系统应该如何处理？
 如何设计一个最小的错误显示机制？

实验2：内核printf与清屏功能实现
实验目标
通过深入分析xv6的输出系统，理解格式化字符串处理原理，独立实现功能完整的内核
printf和清屏功能。

核心学习资料
xv6输出系统架构分析


- 格式化输出实现

kernel/printf.c

 重点函数： printf() ,

printint() ,

printptr()

 学习要点：可变参数处理、数字转字符串算法


kernel/uart.c

- 硬件抽象层

 重点函数： uartputc() ,

uartinit()

 理解：设备驱动的抽象设计


kernel/console.c

- 控制台抽象层

 重点函数： consputc() ,

consolewrite()

 思考：为什么需要这个中间层？

相关技术规范


ANSI转义序列：https://en.wikipedia.org/wiki/ANSI_escape_code

 重点：清屏、光标控制、颜色设置


C语言可变参数：stdarg.h的使用方法
 关键宏：va_start, va_arg, va_end

任务列表
任务1：深入理解xv6输出架构
分析重点：

1. 研读 printf.c 中的核心函数：



printf() 如何解析格式字符串？



printint() 如何处理不同进制转换？

 负数处理有什么特殊考虑？
2. 理解分层设计：
printf() -> consputc() -> uartputc() -> 硬件寄存器

1

 每一层的职责是什么？
 这种设计有什么优势？

深入思考：

 xv6为什么不使用递归进行数字转换？


printint() 中处理 INT_MIN 的技巧是什么？

 如何实现线程安全的printf？

任务2：设计你的输出系统架构
设计要求：

1. 画出你的系统架构图
2. 定义各层的接口
3. 说明与xv6设计的异同

关键设计决策：

 是否需要缓冲区？为什么？
 如何处理格式错误？
 是否支持可变宽度格式？

架构建议：
1

// 硬件层

2

void uart_putc(char c);

3
4

// 控制台层

5

void console_putc(char c);

6

void console_puts(const char *s);

7
8

// 格式化层

9

int printf(const char *fmt, ...);

10

int sprintf(char *buf, const char *fmt, ...);

任务3：实现数字转换核心算法

学习xv6的printint实现，理解以下问题：
1. 为什么要将负数转为正数处理？
2. 如何避免递归导致的栈溢出？
3. 字符数组的组织方式

实现挑战：
1

// 你需要考虑的边界情况

2

static void print_number(int num, int base, int sign) {

3

// 如何处理 INT_MIN？

4

// 如何处理 base=16 的字母输出？

5

// 如何实现逆序输出？

6

}

调试策略：
 先实现十进制正数
 再处理负数边界情况
 最后支持十六进制

任务4：实现格式字符串解析
参考xv6的状态机思路：
1. 普通字符直接输出
2. 遇到%进入格式处理状态
3. 解析格式符并调用相应处理函数

实现要点：
1

int printf(const char *fmt, ...) {

2

va_list ap;

3

va_start(ap, fmt);

4
5

// 你的解析逻辑：

6

// 如何区分 %d, %x, %s, %c, %%？

7

// 如何提取对应的参数？

8

// 如何处理未知格式符？

9

va_end(ap);

10
11

}

测试用例设计：
1

void test_printf_basic() {

2

printf("Testing integer: %d\n", 42);

3

printf("Testing negative: %d\n", -123);

4

printf("Testing zero: %d\n", 0);

5

printf("Testing hex: 0x%x\n", 0xABC);

6

printf("Testing string: %s\n", "Hello");

7

printf("Testing char: %c\n", 'X');

8

printf("Testing percent: %%\n");

9

}

10
11
12

void test_printf_edge_cases() {
printf("INT_MAX: %d\n", 2147483647);

13

printf("INT_MIN: %d\n", -2147483648);

14

printf("NULL string: %s\n", (char*)0);
printf("Empty string: %s\n", "");

15
16

}

任务5：实现清屏功能
ANSI转义序列学习：


\033[2J

- 清除整个屏幕



\033[H

- 光标回到左上角



\033[K

- 清除当前行

实现思路：
1

void clear_screen(void) {

2

// 方案1：发送ANSI转义序列

3

// 方案2：输出足够多的换行符

4

// 方案3：直接控制显示硬件（复杂）

5

}

扩展功能：
 光标定位： goto_xy(int x, int y)
 颜色输出： printf_color(color, fmt, ...)
 清除行： clear_line()

任务6：综合测试与优化
功能测试：

1. 基本格式化功能
2. 边界条件处理
3. 性能测试（大量输出）
4. 错误恢复测试

性能优化考虑：

 字符串输出是否可以批量发送？
 数字转换是否可以查表优化？
 格式解析是否可以预编译？

调试建议
分模块调试

底层验证：先确保单字符输出正常
2. 数字转换：单独测试各种数字格式
3. 字符串处理：测试各种字符串边界情况
4. 综合测试：复杂格式字符串测试
1.

常见问题诊断
输出不完整：

 检查UART发送是否等待完成
 验证字符串是否正确终止
 确认缓冲区大小是否足够

数字输出错误：

 验证进制转换算法
 检查负数处理逻辑
 测试INT_MIN等边界值

格式解析错误：

 打印解析过程的中间状态
 验证va_arg的参数类型匹配
 检查未知格式符的处理

思考题
1.

架构设计：

 为什么需要分层？每层的职责如何划分？
 如果要支持多个输出设备（串口+显示器），架构如何调整？
2.

算法选择：

 数字转字符串为什么不用递归？
 如何在不使用除法的情况下实现进制转换？
3.

性能优化：

 当前实现的性能瓶颈在哪里？
 如何设计一个高效的缓冲机制？
4.

错误处理：

 printf遇到NULL指针应该如何处理？
 格式字符串错误时的恢复策略是什么？

实验3：页表与内存管理
实验目标
通过深入分析xv6的内存管理系统，理解虚拟内存的工作原理，独立实现物理内存分配器
和页表管理系统。

核心学习资料

RISC-V内存管理机制


RISC-V特权级规范 第12章： Supervisor-Level ISA

 12.4


Sv39: Page-Based 39-bit Virtual-Memory System

在线文档：https://github.com/riscv/riscv-isa-manual

xv6内存管理源码分析


- 物理内存分配器

kernel/kalloc.c

 重点函数： kinit() ,

kalloc() ,

kfree()

 学习要点：空闲页链表管理、简单分配算法


- 虚拟内存管理

kernel/vm.c

 重点函数： walk() ,

mappages() ,

uvmcreate()

 学习要点：页表遍历、映射建立、地址转换


- RISC-V相关定义

kernel/riscv.h

 重点内容：页表项格式、权限位定义、地址操作宏

内存管理理论基础


操作系统概念 第9-10章：内存管理和虚拟内存

 在线图书：https://www.os-book.com/OS10/index.html


深入理解计算机系统 第9章：虚拟内存

任务列表

任务1：深入理解Sv39页表机制
学习重点：

1. 分析39位虚拟地址的分解：
1

38

2

|

VPN[2]

30 29

21 20

12 11

0

|

|

|

|

VPN[1]

VPN[0]

 每个VPN段的作用是什么？
 为什么是9位而不是其他位数？
2. 理解页表项（PTE）格式：
 V位：有效性标志
 R/W/X位：读/写/执行权限
 U位：用户态访问权限
 物理页号（PPN）的提取方式

深入思考：

 为什么选择三级页表而不是二级或四级？

offset

 中间级页表项的R/W/X位应该如何设置？
 如何理解"页表也存储在物理内存中"？

任务2：分析xv6的物理内存分配器
代码阅读指导：

1. 研读 kalloc.c 的核心数据结构：
1

struct run {
struct run *next;

2
3

};

 这个设计有什么巧妙之处？
 为什么不需要额外的元数据存储？
2. 分析 kinit() 的初始化过程：
 如何确定可分配的内存范围？
 空闲页链表是如何构建的？
 为什么要按页对齐？
3. 理解 kalloc() 和 kfree() 的实现：
 分配算法的时间复杂度是多少？
 如何防止double-free？
 这种设计的优缺点是什么？

设计思考：

 如果要实现内存统计功能，应该如何扩展？
 如何检测内存泄漏？
 更高效的分配算法有哪些？

任务3：设计你的物理内存管理器
设计要求：

1. 确定内存布局方案
2. 选择合适的数据结构
3. 实现分配和释放接口

关键设计决策：
1

// 你需要决定的接口设计

2

void pmm_init(void);

// 初始化内存管理器

3

void* alloc_page(void);

// 分配一个物理页

4

void free_page(void* page);

// 释放一个物理页

5

void* alloc_pages(int n);

// 分配连续的n个页面（可选）

6
7

// 你需要考虑的问题：

8

// 1. 如何确定可用内存范围？

9

// 2. 如何处理内存碎片？

10

// 3. 是否需要支持不同大小的分配？

实现策略：
1. 首先实现最简单的链表方案
2. 添加基本的错误检查
3. 考虑性能优化（如适用）

任务4：理解xv6的页表管理
代码阅读重点：

1. 分析 walk() 函数的递归遍历：
 如何从虚拟地址提取各级索引？
 遇到无效页表项时如何处理？
 为什么需要 alloc 参数？
2. 研究 mappages() 的映射建立：
 如何处理地址对齐？
 权限位是如何设置的？
 映射失败时的清理工作
3. 理解地址转换宏定义：
1

#define PGROUNDUP(sz)

(((sz)+PGSIZE-1) & ~(PGSIZE-1))

2

#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))

3

#define PTE_PA(pte)

(((pte) >> 10) << 12)

实现挑战：
 如何避免页表遍历中的无限递归？
 映射过程中的内存分配失败应该如何恢复？
 如何确保页表的一致性？

任务5：实现你的页表管理系统
核心接口设计：
1

// 页表类型定义

2

typedef uint64* pagetable_t;

3
4

// 基本操作接口

5

pagetable_t create_pagetable(void);

6

int map_page(pagetable_t pt, uint64 va, uint64 pa, int perm);

7

void destroy_pagetable(pagetable_t pt);

8
9

// 辅助函数（内部使用）

10

pte_t* walk_create(pagetable_t pt, uint64 va);

11

pte_t* walk_lookup(pagetable_t pt, uint64 va);

实现步骤指导：

1.

地址解析实现：

1

// 从虚拟地址提取页表索引

2

#define VPN_SHIFT(level) (12 + 9 * (level))

3

#define VPN_MASK(va, level) (((va) >> VPN_SHIFT(level)) & 0x1FF)

2.

页表遍历实现：

 从根页表开始逐级查找
 检查每一级页表项的有效性
 必要时创建中间级页表
3.

映射建立实现：

 确保地址按页对齐
 正确设置权限位
 处理映射冲突

调试检查点：
1

// 实现页表打印功能用于调试

2

void dump_pagetable(pagetable_t pt, int level) {

3

// 递归打印页表内容

4

// 显示虚拟地址到物理地址的映射关系
// 标明权限位设置

5
6

}

任务6：启用虚拟内存

参考xv6的内核初始化：
1. 研读 kvminit() 的内核页表创建：
 哪些内存区域需要映射？
 为什么采用恒等映射？
 设备内存的权限设置
2. 分析 kvminithart() 的页表激活：
 satp寄存器的格式和设置


sfence.vma 指令的作用

 激活前后的注意事项

实现策略：
1

void kvminit(void) {

2

// 1. 创建内核页表

3

kernel_pagetable = create_pagetable();

4
5

// 2. 映射内核代码段（R+X权限）

6

map_region(kernel_pagetable, KERNBASE, KERNBASE,

7

(uint64)etext - KERNBASE, PTE_R | PTE_X);

8
9

// 3. 映射内核数据段（R+W权限）

10

map_region(kernel_pagetable, (uint64)etext, (uint64)etext,
PHYSTOP - (uint64)etext, PTE_R | PTE_W);

11
12
13

// 4. 映射设备（UART等）

14

map_region(kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);

15

}

16
17

void kvminithart(void) {

18

// 激活内核页表

19

w_satp(MAKE_SATP(kernel_pagetable));

20

sfence_vma();

21

}

关键技术细节：
 SATP寄存器格式： MODE[63:60] | ASID[59:44] | PPN[43:0]
 MODE=8表示Sv39模式


sfence.vma 用于刷新TLB

测试与调试策略
分层测试方法
1.
1

物理内存分配器测试：

void test_physical_memory(void) {

2

// 测试基本分配和释放

3

void *page1 = alloc_page();

4

void *page2 = alloc_page();

5

assert(page1 != page2);

6

assert(((uint64)page1 & 0xFFF) == 0);

7
8

// 测试数据写入

9

*(int*)page1 = 0x12345678;

10

assert(*(int*)page1 == 0x12345678);

11
12

// 测试释放和重新分配

13

free_page(page1);

14

void *page3 = alloc_page();

15

// page3可能等于page1（取决于分配策略）

16
17

free_page(page2);

18

free_page(page3);

19

}

2.
1

页表功能测试：

void test_pagetable(void) {

// 页对齐检查

pagetable_t pt = create_pagetable();

2
3
4

// 测试基本映射

5

uint64 va = 0x1000000;

6

uint64 pa = (uint64)alloc_page();

7

assert(map_page(pt, va, pa, PTE_R | PTE_W) == 0);

8
9

// 测试地址转换

10

pte_t *pte = walk_lookup(pt, va);

11

assert(pte != 0 && (*pte & PTE_V));

12

assert(PTE_PA(*pte) == pa);

13
14

// 测试权限位

15

assert(*pte & PTE_R);

16

assert(*pte & PTE_W);

17

assert(!(*pte & PTE_X));

18

}

3.
1

虚拟内存激活测试：

void test_virtual_memory(void) {
printf("Before enabling paging...\n");

2
3
4

// 启用分页

5

kvminit();

6

kvminithart();

7

printf("After enabling paging...\n");

8
9
10

// 测试内核代码仍然可执行

11

// 测试内核数据仍然可访问

12

// 测试设备访问仍然正常

13

}

常见问题诊断

问题：启用分页后系统崩溃
 检查点1：内核代码是否正确映射？
 检查点2：栈空间是否映射？
 检查点3：设备地址是否映射？
 调试方法：在启用前后打印关键地址的映射状态

问题：页表映射失败

 检查地址对齐：虚拟地址和物理地址都必须页对齐
 检查内存不足：中间页表创建可能失败
 检查权限冲突：重复映射可能导致权限不一致

问题：地址转换错误

 验证VPN提取算法是否正确
 检查PTE格式是否符合RISC-V规范
 确认物理地址计算是否正确

GDB调试技巧
1

# 查看页表内容

2

(gdb) x/64gx $satp_register_content

3

# 查看特定虚拟地址的映射

4

(gdb) monitor info mem

5

# 检查页表遍历过程

6

(gdb) b walk_create

7

(gdb) watch $a0

# 监视页表指针变化

性能优化考虑
内存分配优化

批量分配：一次性分配多个连续页面
2. 分级分配：针对不同大小需求使用不同分配器
3. 缓存优化：保持少量预分配页面池
1.

页表优化

TLB友好：合理安排虚拟地址布局
2. 大页支持：对于大块内存使用大页映射
3. 延迟映射：按需创建页表项
1.

思考题
1.

设计对比：

 你的物理内存分配器与xv6有什么不同？
 为什么选择这种设计？有什么权衡？
2.

内存安全：

 如何防止内存分配器被恶意利用？
 页表权限设置的安全考虑有哪些？
3.

性能分析：

 当前实现的性能瓶颈在哪里？
 如何测量和优化内存访问性能？
4.

扩展性：

 如果要支持用户进程，需要什么修改？
 如何实现内存共享和写时复制？
5.

错误恢复：

 页表创建失败时如何清理已分配的资源？
 如何检测和处理内存泄漏？

实验4：中断处理与时钟管理
实验目标
通过分析xv6的中断处理机制，理解操作系统如何响应硬件事件，实现完整的中断处理框
架和时钟中断驱动的任务调度。

核心学习资料
RISC-V中断机制


RISC-V特权级规范 第3章：Machine-Level ISA

 3.1.9节：Machine Interrupt Registers
 3.2.1节：Machine Timer Registers


RISC-V特权级规范 第12章：Supervisor-Level ISA
 12.1.3节：Supervisor Interrupt Registers
 重点理解：mie、mip、sie、sip寄存器的作用

xv6中断处理源码分析


kernel/trap.c

- 中断和异常处理

 重点函数： usertrap() ,

kerneltrap() ,

devintr()

 学习要点：中断分发、异常处理、系统调用入口


kernel/kernelvec.S

- 内核态中断向量

 重点：上下文保存和恢复机制


kernel/start.c

- 机器模式初始化

 重点函数：timer中断的设置和代理

时钟管理理论


SBI规范：https://github.com/riscv-non-isa/riscv-sbi-doc

 第4.6节：Timer Extension


操作系统概念 第5章：CPU调度

任务列表

任务1：理解RISC-V中断架构
学习重点：

1. 分析中断特权级委托：
 Machine Mode → Supervisor Mode 委托
 medeleg: 异常委托寄存器
 mideleg: 中断委托寄存器
 为什么需要中断委托？
 哪些中断应该委托给S模式？
2. 理解中断寄存器组合：
 mie/sie：中断使能寄存器
 mip/sip：中断挂起寄存器
 mtvec/stvec：中断向量基址
 mcause/scause：中断原因寄存器

深入思考：

 时钟中断为什么在M模式产生，却在S模式处理？
 如何理解"中断是异步的，异常是同步的"？

任务2：分析xv6的中断处理流程
代码阅读指导：

1. 研读 start.c 中的机器模式设置：
1

// 时钟中断委托给S模式

2

w_mideleg(r_mideleg() | (1L << 5));

3

// 设置机器模式陷阱向量

4

w_mtvec((uint64)timervec);

 为什么时钟中断需要特殊处理？


timervec 的作用是什么？

2. 分析 kernelvec.S 的上下文切换：
 哪些寄存器需要保存？
 为什么不保存所有寄存器？
 栈的使用策略是什么？
3. 理解 trap.c 的中断分发：
1

void kerneltrap(void) {

2

// 中断还是异常？

3

// 如何确定中断源？

4

// 如何调用相应处理函数？

5

}

关键问题：
 中断处理中的重入问题如何解决？
 中断处理时间过长会有什么后果？

任务3：设计你的中断处理框架
架构设计要求：

1. 设计中断向量表结构
2. 定义中断处理函数接口
3. 实现中断的注册和注销机制

设计考虑：
1

// 中断处理函数类型

2

typedef void (*interrupt_handler_t)(void);

3
4

// 中断控制接口

5

void trap_init(void);

6

void register_interrupt(int irq, interrupt_handler_t h); // 注册中断处理函数

7

void enable_interrupt(int irq);

// 开启特定中断

8

void disable_interrupt(int irq);

// 关闭特定中断

9
10

// 你需要考虑的问题：

11

// 1. 如何设计中断优先级？

12

// 2. 是否支持中断嵌套？

13

// 3. 如何处理共享中断？

实现策略：
1. 先实现最基本的时钟中断处理
2. 逐步添加其他中断源支持
3. 考虑性能和可扩展性

任务4：实现上下文保存与恢复
参考xv6的kernelvec.S，理解：
1. 哪些寄存器必须保存？
 调用者保存寄存器 vs 被调用者保存寄存器
 临时寄存器的处理策略
 CSR寄存器的保存需求
2. 栈的管理：
 中断栈的分配
 栈溢出检测
 多级中断的栈管理

实现挑战：
1

# 你的中断入口实现框架

2

kernelvec:

3

# 保存上下文

4

# 你需要决定：

// 初始化中断系统

5

# 1. 保存到哪里？内核栈？专用区域？

6

# 2. 保存哪些寄存器？

7

# 3. 如何快速保存和恢复？

8
9

# 调用C处理函数

10

call kerneltrap

11
12

# 恢复上下文并返回

任务5：实现时钟中断与调度
时钟中断处理：

1. 理解SBI时钟接口：
1

// 设置下次时钟中断时间

2

void sbi_set_timer(uint64 time);

3

// 获取当前时间

4

uint64 get_time(void);

2. 实现时钟中断处理函数：
1

void timer_interrupt(void) {

2

// 1. 更新系统时间

3

// 2. 处理定时器事件

4

// 3. 触发任务调度

5

// 4. 设置下次中断时间

6

}

调度器集成：
 如何在时钟中断中触发调度？
 调度的时机选择有什么考虑？
 如何确保调度的原子性？

任务6：异常处理机制
异常类型理解：

1. 指令地址未对齐
2. 指令访问故障
3. 非法指令
4. 断点
5. 加载地址未对齐
6. 加载访问故障
7. 存储地址未对齐
8. 存储访问故障
9. 用户模式环境调用
10. 监督模式环境调用

实现要求：
1

void handle_exception(struct trapframe *tf) {
uint64 cause = r_scause();

2
3
4

switch (cause) {

5

case 8:

// 系统调用

handle_syscall(tf);

6

break;

7

case 12: // 指令页故障

8
9

handle_instruction_page_fault(tf);

10

break;
case 13: // 加载页故障

11
12

handle_load_page_fault(tf);

13

break;
case 15: // 存储页故障

14

handle_store_page_fault(tf);

15

break;

16

default:

17

panic("Unknown exception");

18

}

19
20

}

测试与调试策略
中断功能测试
1
2

void test_timer_interrupt(void) {
printf("Testing timer interrupt...\n");

3
4

// 记录中断前的时间

5

uint64 start_time = get_time();

6

int interrupt_count = 0;

7
8

// 设置测试标志

9

volatile int *test_flag = &interrupt_count;

10
11

// 在时钟中断处理函数中增加计数

12

// 等待几次中断

13

while (interrupt_count < 5) {

14

// 可以在这里执行其他任务

15

printf("Waiting for interrupt %d...\n", interrupt_count + 1);

16

// 简单延时

17

for (volatile int i = 0; i < 1000000; i++);

18

}

19
20

uint64 end_time = get_time();

21

printf("Timer test completed: %d interrupts in %lu cycles\n",

interrupt_count, end_time - start_time);

22
23

}

异常处理测试
1

void test_exception_handling(void) {
printf("Testing exception handling...\n");

2
3
4

// 测试除零异常（如果支持）

5

// 测试非法指令异常

6

// 测试内存访问异常

7

printf("Exception tests completed\n");

8
9

}

性能测试
1

void test_interrupt_overhead(void) {

2

// 测量中断处理的时间开销

3

// 测量上下文切换的成本

4

// 分析中断频率对系统性能的影响

5

}

调试建议
分阶段调试
1.

基础设置验证：

 验证中断寄存器设置是否正确
 检查中断向量地址是否对齐
 确认中断使能位设置
2.

中断触发测试：

 使用简单的时钟中断测试
 在中断处理函数中添加输出确认被调用
 验证中断频率是否符合预期
3.

上下文完整性：

 在中断前后检查寄存器值
 验证栈指针的正确性
 确认中断返回后程序继续正常执行

常见问题诊断

问题：中断无响应
 检查中断使能位设置

 验证中断向量地址
 确认中断源是否正确配置

问题：系统在中断处理后崩溃
 检查栈指针保存和恢复
 验证上下文保存的完整性
 确认中断处理函数没有破坏调用约定

问题：中断频率异常

 检查时钟设置参数
 验证SBI调用是否正确
 确认时间计算没有溢出

思考题
1.

中断设计：

 为什么时钟中断需要在M模式处理后再委托给S模式？
 如何设计一个支持中断优先级的系统？
2.

性能考虑：

 中断处理的时间开销主要在哪里？如何优化？
 高频率中断对系统性能有什么影响？
3.

可靠性：

 如何确保中断处理函数的安全性？
 中断处理中的错误应该如何处理？
4.

扩展性：

 如何支持更多类型的中断源？
 如何实现中断的动态路由？
5.

实时性：

 当前实现的中断延迟特征如何？
 如何设计一个满足实时要求的中断系统？

实验5：进程管理与调度
实验目标
通过深入分析xv6的进程管理机制，理解操作系统如何创建、管理和调度进程，实现完整
的进程生命周期管理和简单的调度算法。

核心学习资料

进程管理理论基础

操作系统概念 第3-5章：进程、线程、CPU调度
 xv6手册 第2-4章：操作系统组织、页表、陷阱和系统调用
 RISC-V调用约定：https://riscv.org/wp-content/uploads/2015/01/riscv-callin


g.pdf

xv6进程管理源码分析


kernel/proc.h

- 进程结构体定义

 重点： struct proc 的字段含义和生命周期


kernel/proc.c

- 进程管理核心函数

 重点函数： allocproc() ,

fork() ,

exit() ,

wait() ,

scheduler()

 学习要点：进程状态转换、内存管理、调度策略


kernel/swtch.S

- 上下文切换汇编代码

 理解：寄存器保存策略、栈切换机制


kernel/sysproc.c

- 进程相关系统调用

 重点： sys_fork() ,

sys_exit() ,

sys_wait() ,

任务列表
任务1：深入理解进程抽象
学习重点：

1. 分析xv6的进程结构体：
1

struct proc {

2

struct spinlock lock;

3

enum procstate state;

// 进程状态

4

void *chan;

// 等待通道

5

int killed;

// 是否被杀死

6

int xstate;

// 退出状态

7

int pid;

// 进程ID

8

pagetable_t pagetable;

// 用户页表

9

struct trapframe *trapframe;

10

struct context context;

11

// ...更多字段

12

};

 每个字段的作用是什么？
 进程状态转换图是怎样的？
 为什么需要锁保护？
2. 理解进程生命周期：

// 陷阱帧

// 调度上下文

sys_kill()

 UNUSED → USED → RUNNABLE → RUNNING → SLEEPING → ZOMBIE
 每个状态转换的触发条件是什么？
 哪些操作需要原子性保护？

深入思考：

 为什么需要ZOMBIE状态？
 进程表的大小限制有什么影响？
 如何防止进程ID重复？

任务2：分析xv6的进程创建机制
代码阅读指导：

1. 研读 allocproc() 函数：
 如何在进程表中找到空闲槽位？
 进程ID是如何分配的？
 用户栈是如何设置的？
 陷阱帧的初始化过程
2. 深入理解 fork() 实现：
1

int fork(void) {

2

// 1. 分配新进程结构

3

// 2. 复制用户内存

4

// 3. 复制陷阱帧

5

// 4. 设置返回值
// 5. 标记为RUNNABLE

6
7

}

 为什么父子进程有不同的返回值？
 内存复制是如何实现的？
 失败时的资源清理策略
3. 分析进程退出机制：


exit() 与 wait() 的协作关系

 资源回收的时机和方式
 孤儿进程的处理

关键问题：

 fork()的性能瓶颈在哪里？
 如何实现写时复制优化？

任务3：设计你的进程管理系统
设计要求：

1. 确定进程结构体设计

2. 选择合适的进程表组织方式
3. 设计进程ID分配策略

核心接口设计：
1

// 进程管理基本接口

2

struct proc* alloc_process(void);

// 分配进程结构

3

void free_process(struct proc *p);

// 释放进程资源

4

int create_process(void (*entry)(void)); // 创建新进程

5

void exit_process(int status);

// 终止当前进程

6

int wait_process(int *status);

// 等待子进程

7
8

// 你需要考虑的设计问题：

9

// 1. 进程表用数组还是链表？

10

// 2. 如何高效查找特定PID的进程？

11

// 3. 是否需要进程组和会话的概念？

12

// 4. 如何处理进程资源限制？

实现策略：
1. 先实现基本的进程创建和销毁
2. 再添加父子关系管理
3. 最后考虑性能优化

任务4：实现上下文切换机制
参考xv6的swtch.S，理解：
1. 上下文切换的本质：
 哪些寄存器需要保存？
 为什么不保存所有寄存器？
 调用者保存 vs 被调用者保存的区别
2. 栈的切换：
 内核栈 vs 用户栈的管理
 栈指针的保存和恢复
 栈溢出的检测和预防

实现挑战：
1

// 上下文结构体设计

2

struct context {

3

uint64 ra;

// 返回地址

4

uint64 sp;

// 栈指针

5

// 需要保存哪些其他寄存器？
// 为什么这样选择？

6
7

};

8
9

// 上下文切换函数

10

void swtch(struct context *old, struct context *new);

关键技术点：
 上下文切换必须是原子操作
 中断状态的管理
 多级栈的处理

任务5：实现调度器

参考xv6的调度策略：
1. 分析 scheduler() 函数：
 轮转调度的实现方式
 如何避免忙等待？
 为什么需要开启中断？
2. 理解调度时机：
 主动调度 vs 抢占调度


yield() 函数的作用

 时钟中断如何触发调度

调度器设计考虑：
1

void scheduler(void) {

2

struct proc *p;

3

struct cpu *c = mycpu();

4
5

c->proc = 0;

6

for(;;) {

7

// 开启中断，允许设备中断

8

intr_on();

9
10

// 你的调度算法：

11

// 1. 如何选择下一个运行的进程？

12

// 2. 如何处理优先级？

13

// 3. 如何避免饥饿？

14

// 4. 如何平衡公平性和效率？

15

for(p = proc; p < &proc[NPROC]; p++) {

16
17

acquire(&p->lock);

18

if(p->state == RUNNABLE) {

19

// 找到可运行进程，切换过去

20

p->state = RUNNING;

21

c->proc = p;

22

swtch(&c->context, &p->context);
c->proc = 0;

23
24

}

25

release(&p->lock);
}

26
27

}

28

}

扩展调度算法：
 优先级调度
 多级反馈队列
 完全公平调度器(CFS)

任务6：实现进程同步原语

基于xv6的sleep/wakeup机制：
1. 理解条件变量的概念：
1

// 等待条件满足

2

void sleep(void *chan, struct spinlock *lk);

3

// 唤醒等待特定条件的进程

4

void wakeup(void *chan);

2. 分析典型使用模式：
a. 生产者-消费者问题
b. 读者-写者问题
c. 信号量的实现

实现要点：

 避免lost wakeup问题
 锁的正确使用
 中断状态的管理

测试与调试策略
进程创建测试
1
2

void test_process_creation(void) {
printf("Testing process creation...\n");

3
4

// 测试基本的进程创建

5

int pid = create_process(simple_task);

6

assert(pid > 0);

7
8

// 测试进程表限制

9

int pids[NPROC];

10

int count = 0;

11

for (int i = 0; i < NPROC + 5; i++) {

12

int pid = create_process(simple_task);

13

if (pid > 0) {

14
15
16

pids[count++] = pid;
} else {
break;

}

17
18

}

19

printf("Created %d processes\n", count);

20
21

// 清理测试进程

22

for (int i = 0; i < count; i++) {
wait_process(NULL);

23

}

24
25

}

调度器测试
1

void test_scheduler(void) {
printf("Testing scheduler...\n");

2
3
4

// 创建多个计算密集型进程

5

for (int i = 0; i < 3; i++) {
create_process(cpu_intensive_task);

6

}

7
8
9

// 观察调度行为

10

uint64 start_time = get_time();

11

sleep(1000);

12

uint64 end_time = get_time();

// 等待1秒

13

printf("Scheduler test completed in %lu cycles\n",

14

end_time - start_time);

15
16

}

同步机制测试
1

void test_synchronization(void) {

2

// 测试生产者-消费者场景

3

shared_buffer_init();

4
5

create_process(producer_task);

6

create_process(consumer_task);

7
8

// 等待完成

9

wait_process(NULL);

10

wait_process(NULL);

11

printf("Synchronization test completed\n");

12
13

}

调试建议

进程状态调试
1

void debug_proc_table(void) {

2

printf("=== Process Table ===\n");

3

for (int i = 0; i < NPROC; i++) {

4

struct proc *p = &proc[i];

5

if (p->state != UNUSED) {
printf("PID:%d State:%d Name:%s\n",

6

p->pid, p->state, p->name);

7

}

8

}

9
10

}

调度器调试
 在调度器中添加统计信息
 跟踪进程运行时间
 分析调度延迟

内存泄漏检测
 跟踪进程创建和销毁
 检查页表释放
 监控进程表使用情况

思考题
1.

进程模型：

 为什么选择这种进程结构设计？
 如何支持轻量级线程？
2.

调度策略：

 轮转调度的公平性如何？
 如何实现实时调度？
3.

性能优化：

 fork()的性能瓶颈如何解决？
 上下文切换开销如何降低？
4.

资源管理：

 如何实现进程资源限制？
 如何处理进程资源泄漏？
5.

扩展性：

 如何支持多核调度？
 如何实现负载均衡？

实验6：系统调用
实验目标
通过分析xv6的系统调用机制，深入理解用户态与内核态的交互方式，实现完整的系统调
用框架和常用系统调用功能。

核心学习资料
系统调用理论基础

操作系统概念 第2章：操作系统结构
 RISC-V特权级规范 第12.1节：Supervisor Trap Handling
 xv6手册 第2.5节和第4章：系统调用和陷阱


xv6系统调用源码分析


kernel/syscall.c

- 系统调用分发机制

 重点函数： syscall() ,

argint() ,

argstr() ,

 学习要点：参数传递、返回值处理、错误检查


kernel/sysproc.c

- 进程相关系统调用实现



kernel/sysfile.c

- 文件相关系统调用实现



user/usys.pl



kernel/trampoline.S

- 用户态系统调用桩代码生成
- 用户态/内核态切换

RISC-V系统调用约定

调用约定：ecall指令、寄存器使用、参数传递
 特权级切换：用户模式到监督模式的转换过程


任务列表

任务1：理解系统调用的实现原理
学习重点：

1. 分析系统调用的完整流程：
1

用户程序调用 → usys.S桩代码 → ecall指令 →

2

uservec → usertrap → syscall → 系统调用实现 →

3

返回用户态

 每个环节的作用是什么？
 参数是如何传递的？

argaddr()

 返回值如何返回？
2. 研究RISC-V的ecall机制：
 ecall指令的作用
 scause寄存器中系统调用的编码
 sepc寄存器的作用和更新
3. 理解特权级切换：
 用户栈到内核栈的转换
 寄存器状态的保存和恢复
 页表的切换时机

深入思考：

 为什么需要陷阱帧(trapframe)？
 系统调用和中断处理有什么相同和不同？

任务2：分析xv6的系统调用分发机制
代码阅读指导：

1. 研读 syscall.c 中的核心分发逻辑：
1

void syscall(void) {

2

int num;

3

struct proc *p = myproc();

4
5

num = p->trapframe->a7;

6

if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
p->trapframe->a0 = syscalls[num]();

7

// 调用并保存返回值

} else {

8

// 处理无效系统调用

9

}

10
11

// 系统调用号

}

 系统调用号是如何传递的？
 返回值存储在哪里？
 错误处理机制是什么？
2. 分析参数提取函数：
1

int argint(int n, int *ip);

// 获取整数参数

2

int argaddr(int n, uint64 *ip);

// 获取地址参数

3

int argstr(int n, char *buf, int max);

 参数是从哪里提取的？
 如何处理不同类型的参数？
 边界检查是如何实现的？
3. 理解用户内存访问：

// 获取字符串参数



copyout() 和 copyin() 的作用

 为什么不能直接访问用户内存？
 如何防止用户传递恶意指针？

任务3：设计你的系统调用框架
设计要求：

1. 定义系统调用表结构
2. 设计参数传递机制
3. 实现错误处理策略

核心组件设计：
1

// 系统调用描述符

2

struct syscall_desc {

3

int (*func)(void);

// 实现函数

4

char *name;

// 系统调用名称

5

int arg_count;

// 参数个数

6

// 可选：参数类型描述

7

};

8
9

// 系统调用表

10

extern struct syscall_desc syscall_table[];

11
12

// 系统调用分发器

13

void syscall_dispatch(void);

14
15

// 参数提取辅助函数

16

int get_syscall_arg(int n, long *arg);

17

int get_user_string(const char __user *str, char *buf, int max);

18

int get_user_buffer(const void __user *ptr, void *buf, int size);

19
20

// 你需要考虑的问题：

21

// 1. 如何验证用户提供的指针？

22

// 2. 如何处理系统调用失败？

23

// 3. 如何支持可变参数的系统调用？

24

// 4. 如何实现系统调用的权限检查？

任务4：实现基础系统调用
必需实现的系统调用：
1. 进程控制类：
1

int sys_fork(void);

// 创建子进程

2

int sys_exit(void);

// 终止进程

3

int sys_wait(void);

// 等待子进程

4

int sys_kill(void);

// 发送信号

5

int sys_getpid(void);

// 获取进程ID

2.

文件操作类：

1

int sys_open(void);

// 打开文件

2

int sys_close(void);

// 关闭文件

3

int sys_read(void);

// 读文件

4

int sys_write(void);

// 写文件

3.

内存管理类：

1

void* sys_sbrk(void);

2

// 可选：mmap, munmap等

// 调整堆大小

实现策略：
1

// 以sys_write为例

2

int sys_write(void) {

3

int fd;

4

char *buf;

5

int count;

6
7

// 1. 提取参数

8

if (argint(0, &fd) < 0 ||

9

argaddr(1, (uint64*)&buf) < 0 ||

10

argint(2, &count) < 0) {
return -1;

11

}

12
13
14

// 2. 参数有效性检查

15

if (fd < 0 || fd >= NOFILE || count < 0) {
return -1;

16

}

17
18

// 3. 调用内核函数实现

19

return filewrite(myproc()->ofile[fd], buf, count);

20
21

}

任务5：实现用户态系统调用接口
参考xv6的usys.pl，理解：
1. 桩代码生成机制：
1

# 每个系统调用的桩代码格式

2

.global write

3

write:

4

li a7, SYS_write

# 系统调用号加载到a7

5

ecall

# 陷入内核

6

ret

# 返回

2. 用户库函数设计：
1

// 用户库中的系统调用声明

2

int fork(void);

3

int exit(int) __attribute__((noreturn));

4

int wait(int*);

5

int pipe(int*);

6

int write(int, const void*, int);

7

int read(int, void*, int);

8

// ...

实现考虑：
 如何处理系统调用的错误返回？
 是否需要errno机制？
 如何提供用户友好的接口？

任务6：系统调用安全性
安全检查要点：
1. 指针验证：
1

// 检查用户指针是否有效

2

int check_user_ptr(const void *ptr, int size) {

3

// 1. 指针是否在用户地址空间？

4

// 2. 内存区域是否有相应权限？

5

// 3. 是否会越界访问？
}

6

2.

缓冲区保护：

 防止缓冲区溢出
 检查字符串是否正确终止
 限制数据传输大小
3.

权限检查：

 文件访问权限
 进程操作权限
 资源使用限制
4.

竞态条件防护：

 TOCTTOU攻击防护
 原子操作保证
 锁的正确使用

测试与调试策略
基础功能测试
1
2

void test_basic_syscalls(void) {
printf("Testing basic system calls...\n");

3
4

// 测试getpid

5

int pid = getpid();

6

printf("Current PID: %d\n", pid);

7
8

// 测试fork

9

int child_pid = fork();

10

if (child_pid == 0) {

11

// 子进程

12

printf("Child process: PID=%d\n", getpid());

13

exit(42);

14

}

15

else if (child_pid > 0) {

16

// 父进程

17

int status;

18

wait(&status);
printf("Child exited with status: %d\n", status);

19
20

}

21

else {
printf("Fork failed!\n");

22

}

23
24

}

参数传递测试
1

void test_parameter_passing(void) {

2

// 测试不同类型参数的传递

3

char buffer[] = "Hello, World!";

4

int fd = open("/dev/console", O_RDWR);

5

if (fd >= 0) {

6
7

int bytes_written = write(fd, buffer, strlen(buffer));

8

printf("Wrote %d bytes\n", bytes_written);

9

close(fd);
}

10
11
12

// 测试边界情况

13

write(-1, buffer, 10);

// 无效文件描述符

14

write(fd, NULL, 10);

// 空指针

15

write(fd, buffer, -1);

// 负数长度

16

}

安全性测试
1

void test_security(void) {

2

// 测试无效指针访问

3

char *invalid_ptr = (char*)0x1000000;

4

int result = write(1, invalid_ptr, 10);

// 可能无效的地址

printf("Invalid pointer write result: %d\n", result);

5
6
7

// 测试缓冲区边界

8

char small_buf[4];

9

result = read(0, small_buf, 1000);

// 尝试读取超过缓冲区大小

10

// 测试权限检查

11

// ...

12
13

}

性能测试
1

void test_syscall_performance(void) {

2

uint64 start_time = get_time();

3
4

// 大量系统调用测试

5

for (int i = 0; i < 10000; i++) {
getpid();

6

// 简单的系统调用

}

7
8
9

uint64 end_time = get_time();

10

printf("10000 getpid() calls took %lu cycles\n",
end_time - start_time);

11
12

}

调试建议
系统调用跟踪
1

// 在syscall.c中添加调试信息

2

void syscall(void) {

3

int num;

4

struct proc *p = myproc();

5

num = p->trapframe->a7;

6
7
8

// 调试输出

9

if (debug_syscalls) {
printf("PID %d: syscall %d (%s)\n",

10

p->pid, num, syscall_names[num]);

11

}

12
13

// 原有逻辑...

14
15

}

参数检查调试
 在参数提取函数中添加验证日志

 跟踪用户内存访问
 记录异常的参数值

性能分析
 测量系统调用延迟
 分析频繁调用的系统调用
 识别性能瓶颈

思考题
1.

设计权衡：

 系统调用的数量应该如何确定？
 如何平衡功能性和安全性？
2.

性能优化：

 系统调用的主要开销在哪里？
 如何减少用户态/内核态切换开销？
3.

安全考虑：

 如何防止系统调用被滥用？
 如何设计安全的参数传递机制？
4.

扩展性：

 如何添加新的系统调用？
 如何保持向后兼容性？
5.

错误处理：

 系统调用失败时应该如何处理？
 如何向用户程序报告详细的错误信息？

实验7：文件系统
实验目标
通过深入分析xv6的简化文件系统，理解现代文件系统的核心概念和实现原理，独立实现
一个功能完整的日志文件系统。

核心学习资料
文件系统理论基础

操作系统概念 第13-14章：文件系统接口和实现
 xv6手册 第10章：文件系统


xv6文件系统源码分析


- 文件系统结构定义

kernel/fs.h

 重点：超级块、inode、目录项的格式


- 文件系统核心实现

kernel/fs.c

 重点函数： ialloc() ,


iget() ,

iput() ,

namei()

- 文件描述符管理

kernel/file.c

 重点：打开文件表、文件描述符分配


- 日志系统实现

kernel/log.c

 重点：事务处理、崩溃恢复、写前日志


- 块缓存管理

kernel/bio.c

 重点：缓存策略、磁盘I/O调度

磁盘和存储

理解磁盘结构：扇区、柱面、磁头
 QEMU磁盘模拟：virtio-blk设备的使用


任务列表

任务1：理解xv6文件系统布局
学习重点：

1. 分析磁盘布局结构：
1

| boot | super | log | inode blocks | bitmap | data blocks |

2

|

0

|

1

| 2-? |

3

- 每个区域的作用是什么？

4

- 为什么要这样组织？

5

- 各区域的大小如何确定？

?-?

|

?

2. 理解超级块（superblock）的作用：
1

struct superblock {

2

uint magic;

// 文件系统魔数

3

uint size;

// 文件系统大小（块数）

4

uint nblocks;

// 数据块数量

5

uint ninodes;

// inode数量

6

uint nlog;

// 日志块数量

7

uint logstart;

// 日志起始块号

8

uint inodestart;

// inode区起始块号

uint bmapstart;

// 位图起始块号

9
10

};

 为什么需要这些元数据？

|

?-end

|

 如何确保超级块的一致性？
3. 深入理解inode结构：
1

struct dinode {

2

short type;

// 文件类型

3

short major;

// 主设备号

4

short minor;

// 次设备号

5

short nlink;

// 硬链接计数

6

uint size;

// 文件大小

7

uint addrs[NDIRECT+1]; // 数据块地址
};

8



直接块和间接块的设计思路

 如何支持大文件？
 硬链接机制的实现

深入思考：

 为什么选择这种简单的布局？
 如何提高空间利用率？
 现代文件系统有什么改进？

任务2：分析xv6的inode管理机制
代码阅读指导：

1. 研读inode缓存管理：
1

struct inode {

2

uint dev;

// 设备号

3

uint inum;

// inode号

4

int ref;

// 引用计数

5

struct sleeplock lock; // 保护inode内容

6

int valid;

7

// 从磁盘拷贝的内容

8

short type;

9

short major;

10

short minor;

11

short nlink;

12

uint size;

13

uint addrs[NDIRECT+1];

14

};



// inode已从磁盘读取？

内存inode和磁盘inode的关系

 引用计数的作用和管理
 缓存一致性如何保证
2. 分析inode分配算法：
1

struct inode* ialloc(uint dev, short type) {

2

// 1. 在inode位图中找空闲inode

3

// 2. 初始化inode内容

4

// 3. 写入磁盘

5

// 4. 返回内存中的inode

6

}

 如何快速找到空闲inode？
 分配失败时的处理策略
 并发分配的同步机制
3. 理解文件数据块管理：
1

static uint bmap(struct inode *ip, uint bn) {

2

// bn是文件内的逻辑块号

3

// 返回对应的物理块号

4

// 处理直接块和间接块的映射

5

}

 逻辑块号到物理块号的转换
 间接块的实现机制
 如何扩展文件大小

关键问题：

 inode缓存的替换策略是什么？
 如何防止inode泄漏？
 大文件的性能问题如何解决？

任务3：设计你的文件系统布局
设计要求：

1. 确定磁盘分区方案
2. 设计inode和数据块组织
3. 选择合适的块大小

设计考虑：
1

// 你的文件系统布局设计

2

#define BLOCK_SIZE

4096

// 块大小选择的考虑

3

#define SUPERBLOCK_NUM

1

// 超级块位置

4

#define LOG_START

2

// 日志区起始

5

#define LOG_SIZE

30

// 日志区大小

6

// inode设计

7

struct my_inode {

8

uint16_t mode;

// 文件模式和类型

9

uint16_t uid;

// 所有者ID

10

uint32_t size;

// 文件大小

11

uint32_t blocks;

// 分配的块数

12

uint32_t atime, mtime, ctime; // 时间戳

13

uint32_t direct[12];

// 直接块指针

14

uint32_t indirect;

// 一级间接块

uint32_t double_indirect;

// 二级间接块（可选）

15
16

};

17

// 你需要考虑的问题：

18

// 1. 如何平衡小文件和大文件的效率？

19

// 2. 是否需要扩展属性支持？

20

// 3. 如何优化目录性能？

21

// 4. 是否支持符号链接？

任务4：实现块缓存系统
参考xv6的bio.c，理解：
1. 缓存结构设计：
1

struct buf {

2

int valid;

// 缓存是否有效

3

int disk;

// 是否需要写回磁盘

4

uint dev;

// 设备号

5

uint blockno;

// 块号

6

struct sleeplock lock; // 保护缓存内容

7

uint refcnt;

8

struct buf *prev, *next; // LRU链表

9

uchar data[BSIZE];

// 引用计数
// 实际数据

};

10

2. 缓存管理策略：
1

struct buf* bread(uint dev, uint blockno);

// 读取块

2

void bwrite(struct buf *b);

// 写入块

3

void brelse(struct buf *b);

// 释放块

实现挑战：
1

// 你的块缓存实现

2

struct buffer_head {

3

uint32_t block_num;

// 块号

4

char *data;

// 数据指针

5

int dirty;

// 脏位

6

int ref_count;

// 引用计数

7

struct buffer_head *next;

// 哈希链表

8

struct buffer_head *lru_next, *lru_prev; // LRU链表

9

};

10

// 关键函数设计

11

struct buffer_head* get_block(uint dev, uint block);

12

void put_block(struct buffer_head *bh);

13

void sync_block(struct buffer_head *bh);

14

void flush_all_blocks(uint dev);

15

// 考虑的问题：

16

// 1. 缓存大小如何确定？

17

// 2. 什么时候触发写回？

18

// 3. 如何处理I/O错误？

19

// 4. 预读策略是否需要？

任务5：实现日志系统

参考xv6的log.c，深入理解：
1. 日志的作用和原理：
 写前日志(Write-Ahead Logging)
 事务的原子性保证
 崩溃恢复机制
2. 日志结构设计：
struct logheader {

1
2

int n;

3

int block[LOGSIZE]; // 每个块在文件系统中的位置

// 日志中的块数

};

4

3. 事务处理流程：
1

void begin_op(void);

2

// 开始事务

void log_write(struct buf *b); // 记录写操作

3

void end_op(void);

// 提交事务

实现要点：
1

// 日志系统状态

2

struct log_state {

3

struct spinlock lock;

4

int start;

// 日志区起始块号

5

int size;

// 日志区大小

6

int outstanding;

// 未完成的系统调用数

7

int committing;

// 是否正在提交

int dev;

// 设备号

8
9

};

10

// 关键实现函数

11

void log_init(int dev, struct superblock *sb);

12

void begin_transaction(void);

13

void end_transaction(void);

14

void log_block_write(struct buffer_head *bh);

15

void recover_log(void);

16

// 设计考虑：

17

// 1. 日志大小如何确定？

18

// 2. 如何处理日志满的情况？

19

// 3. 恢复过程如何确保幂等性？

20

// 4. 如何优化日志性能？

任务6：实现目录和路径解析

理解xv6的目录机制：
1. 目录项格式：
1

struct dirent {

2

ushort inum;

// inode号，0表示空闲

3

char name[DIRSIZ];

// 文件名

};

4

2. 路径解析算法：
1

static struct inode* namex(char *path, int nameiparent, char *name) {
// 解析路径，返回对应的inode

2

// nameiparent=1时返回父目录inode

3
4

}

实现挑战：
1

// 目录操作接口

2

struct inode* dir_lookup(struct inode *dp, char *name, uint *poff);

3

int dir_link(struct inode *dp, char *name, uint inum);

4

int dir_unlink(struct inode *dp, char *name);

5

// 路径解析

6

struct inode* path_walk(char path); struct inode path_parent(char *pa
th, char *name);

7

// 需要考虑的问题：

8

// 1. 目录的最大大小限制

9

// 2. 长文件名的支持

10

// 3. 目录遍历的效率

11

// 4. 硬链接和符号链接的处理

测试与调试策略
文件系统完整性测试
1

void test_filesystem_integrity(void) {

2

printf("Testing filesystem integrity…\n");

3

// 创建测试文件

4

int fd = open("testfile", O_CREATE | O_RDWR);

5

assert(fd >= 0);

6
7

// 写入数据

8

char buffer[] = "Hello, filesystem!";

9

int bytes = write(fd, buffer, strlen(buffer));

10

assert(bytes == strlen(buffer));

11

close(fd);

12
13

// 重新打开并验证

14

fd = open("testfile", O_RDONLY);

15

assert(fd >= 0);

16
17

char read_buffer[64];

18

bytes = read(fd, read_buffer, sizeof(read_buffer));

19

read_buffer[bytes] = '\0';

20
21

assert(strcmp(buffer, read_buffer) == 0);

22

close(fd);

23
24

// 删除文件

25

assert(unlink("testfile") == 0);

26

printf("Filesystem integrity test passed\n");

27
28

}

并发访问测试
1
2
3

void test_concurrent_access(void) {
printf("Testing concurrent file access…
");

4

// 创建多个进程同时访问文件系统

5

for (int i = 0; i < 4; i++) {
if (fork() == 0) {

6
7

// 子进程：创建和删除文件

8

char filename[32];

9

snprintf(filename, sizeof(filename), "test_%d", i);

10

for (int j = 0; j < 100; j++) {

11
12

int fd = open(filename, O_CREATE | O_RDWR);

13

if (fd >= 0) {

14

write(fd, &j, sizeof(j));

15

close(fd);

16

unlink(filename);
}

17
18

}

19

exit(0);
}

20
21

}

22
23

// 等待所有子进程完成

24

for (int i = 0; i < 4; i++) {
wait(NULL);

25
26

}

27
28

printf("Concurrent access test completed

崩溃恢复测试
1

void test_crash_recovery(void) {

printf("Testing crash recovery…

2
3

");

4

// 模拟崩溃场景：

5

// 1. 开始大量文件操作

6

// 2. 在中途"崩溃"（重启系统）

7

// 3. 检查文件系统一致性

8
9

// 注意：这个测试需要特殊的测试框架

10

// 可以通过修改内核代码来模拟崩溃

性能测试
1

void test_filesystem_performance(void) {

2

printf("Testing filesystem performance…\n");

3

uint64 start_time = get_time();

4
5

// 大量小文件测试

6

for (int i = 0; i < 1000; i++) {

7

char filename[32];

8

snprintf(filename, sizeof(filename), "small_%d", i);

9
10

int fd = open(filename, O_CREATE | O_RDWR);

11

write(fd, "test", 4);
close(fd);

12
13

}

14
15

uint64 small_files_time = get_time() - start_time;

16
17

// 大文件测试

18

start_time = get_time();

19

int fd = open("large_file", O_CREATE | O_RDWR);

20

char large_buffer[4096];

21

for (int i = 0; i < 1024; i++) {

// 4MB文件

write(fd, large_buffer, sizeof(large_buffer));

22
23

}

24

close(fd);

25
26

uint64 large_file_time = get_time() - start_time;

27
28

printf("Small files (1000x4B): %lu cycles\n", small_files_time);

29

printf("Large file (1x4MB): %lu cycles\n", large_file_time);

30
31

// 清理测试文件

32

for (int i = 0; i < 1000; i++) {

33

char filename[32];

34

snprintf(filename, sizeof(filename), "small_%d", i);

35

unlink(filename);

36

}

unlink("large_file");

37
38

}

调试建议
文件系统状态检查
1

void debug_filesystem_state(void) {
printf("=== Filesystem Debug Info ===

2
3

");

4

// 显示超级块信息

5

struct superblock sb;

6

read_superblock(&sb);

7

printf("Total blocks: %d

8

", sb.size);
printf("Free blocks: %d

9
10

", count_free_blocks());
printf("Free inodes: %d

11
12

", count_free_inodes());

13

// 显示块缓存状态

14

printf("Buffer cache hits: %d

15
16

", buffer_cache_hits);
printf("Buffer cache misses: %d

17

inode追踪
1

void debug_inode_usage(void) {

2

printf("=== Inode Usage ===\n");

3

for (int i = 0; i < NINODE; i++) {

4

struct inode *ip = &icache.inode[i];

5

if (ip->ref > 0) {
printf("Inode %d: ref=%d, type=%d, size=%d\n",

6

ip->inum, ip->ref, ip->type, ip->size);

7

}

8

}

9
10

}

磁盘I/O统计
1

void debug_disk_io(void) {
printf("=== Disk I/O Statistics ===

2
3
4
5
6
7

");
printf("Disk reads: %d
", disk_read_count);
printf("Disk writes: %d
", disk_write_count);

思考题
1.

设计权衡：

 xv6的简单文件系统有什么优缺点？
 如何在简单性和性能之间平衡？
2.

一致性保证：

 日志系统如何确保原子性？
 如果在恢复过程中再次崩溃会怎样？
3.

性能优化：

 文件系统的主要性能瓶颈在哪里？
 如何改进目录查找的效率？
4.

可扩展性：

 如何支持更大的文件和文件系统？
 现代文件系统有哪些先进特性？
5.

可靠性：

 如何检测和修复文件系统损坏？
 如何实现文件系统的在线检查？

实验8：系统扩展项目
实验概述
经过前面的七个实验，你已经构建了一个基本的操作系统，接下来需要进一步完善这个
系统。你可以从用户角度思考，选择一个扩展方向进行独立设计和实现，使得系统变得
更好用或更有效率。

扩展项目列表
以下是各个可选项目的任务概述：

项目1：优先级调度系统

分析当前简单调度器（如轮转调度）的性能瓶颈，设计并实现支持进程优先级的调度算
法，平衡实时任务的响应性需求与普通任务的公平性保证，提升系统整体调度效率。

项目2：ELF加载器与用户空间

实现标准ELF可执行文件格式的解析和加载机制，建立完整的用户态程序执行环境，包
括虚拟内存映射、程序段加载、动态链接支持等，使系统能够运行标准编译的用户程
序。

项目3：进程间通信系统

设计并实现多种IPC机制（如管道、消息队列、共享内存、信号量等），为用户进程提
供高效的数据交换和同步原语，支持复杂的多进程协作应用场景。

项目4：内核日志系统

构建结构化的内核日志框架，支持不同级别的日志记录、缓冲管理、格式化输出，为系
统调试、性能分析和故障诊断提供完善的信息收集和查看机制。

项目5：Copy-on-Write Fork

优化进程创建机制，实现写时复制技术，使fork操作只复制页表而延迟实际内存复制，
显著减少内存使用和进程创建开销，提升系统性能和资源利用率。

