# 实验四：中断处理与时钟管理

## 实验目标

本实验为内核引入了处理异步事件的能力，目标是建立一个完整的陷阱（Trap）处理框架，使其能够响应硬件中断和同步异常。  我们将重点实现对 **RISC-V 时钟中断** 的捕获和处理，这是未来实现多任务调度的“心跳”。

## 核心实现

### 1. 中断入口与上下文切换 (`kernel/kernelvec.S`)

当中断或异常发生时，CPU 会强制跳转到 `stvec` 寄存器指定的地址。我们创建了 `kernelvec.S` 作为这个统一的汇编入口点。
* **上下文保存**: 为了不破坏中断发生前的程序状态，入口代码的第一件事就是将所有 32 个通用寄存器（`ra`, `sp`, `gp`, `tp`, `a0-a7` 等）压入当前内核栈。
* **调用 C 处理函数**: 保存完上下文后，使用 `call kerneltrap` 指令跳转到 C 语言实现的总处理函数。
* **上下文恢复**: 从 `kerneltrap` 返回后，从栈中按相反的顺序恢复所有寄存器。
* **中断返回**: 最后，执行 `sret` (Supervisor Return) 指令，CPU 会恢复到中断前的状态并从中断指令的下一条继续执行。

### 2. 中断处理框架 (`kernel/trap.c`)

这是中断处理的 C 语言核心部分。
* **初始化 (`trap_init`)**: 该函数将 `kernelvec` 的地址写入 `stvec` 寄存器，完成了中断向量的设置。
* **时钟初始化 (`clock_init`)**: 为了接收时钟中断，该函数通过设置 `sie`  寄存器中的 `STIE` 位来开启时钟中断。
* **陷阱分发 (`kerneltrap`)**: 这是由 `kernelvec.S` 调用的总入口。它通过读取 `scause` (Supervisor Cause) 寄存器来判断陷阱的原因。
    * 如果 `scause` 的最高位为 1，表示这是一个异步中断。我们进一步判断中断号是否为 5（S-mode 时钟中断）。
    * 如果是时钟中断，我们增加一个全局计数器 `tick_counter`，并周期性地打印 "tick: ..." 信息，以证明中断处理函数被正确调用。

### 3. 内核主流程 (`kernel/main.c`)

在 `kmain` 函数中，我们在虚拟内存启用后，依次调用 `trap_init()` 和 `clock_init()`。最后，通过设置 `sstatus` 寄存器中的 `SIE`  位，来**全局开启 S-mode 的中断**。只有这样，CPU 才会真正响应 `sie` 中已启用的中断源。

## 关键调试过程与概念

本次实验引入了更复杂的系统环境，解决了一些关键问题：

* **与 OpenSBI 固件交互**: 为了遵循标准的 RISC-V 启动流程，我们放弃了 `-bios none` 模式，转而让 QEMU 加载默认的 OpenSBI 固件。OpenSBI 负责处理 M-mode 的所有底层初始化，包括设置中断委托，然后将 CPU 切换到 S-mode 再启动我们的内核。
* **内存地址冲突**: OpenSBI 默认加载在 `0x80000000`，这与我们之前内核的加载地址冲突。解决方案是将内核的 `BASE_ADDRESS` 修改为 `0x80200000`（在 `kernel.ld` 中），并同步更新 `vm.c` 中的内核页表映射关系，为固件留出空间。
* **中断委托**: 理解了 RISC-V 的特权级模型，即硬件中断默认由 M-mode 捕获，必须由 M-mode 固件（如 OpenSBI）通过 `mideleg` 寄存器委托给 S-mode，我们的内核才能收到它们。

## 实验结果

编译并运行修改后的代码，QEMU 成功启动。在打印完所有初始化信息后，终端开始周期性地、稳定地输出 "tick: ..."，表明内核已经建立起一套完整且正确的中断处理机制，并能规律地响应硬件时钟中断。