# 实验三：页表与内存管理

## 实验目标

本实验的目标是为我们的内核构建两项核心的内存管理功能：一个简单的物理内存页分配器和一个符合 RISC-V Sv39 规范的页表管理系统。  最终，内核将成功激活 MMU（内存管理单元），并运行在虚拟内存环境中。

## 核心实现

### 1. 物理内存分配器 (`kernel/kalloc.c`)

该模块负责管理以页（4KB）为单位的物理内存。

* **数据结构**: 我们采用了一种高效且简洁的方法来管理空闲内存：将所有空闲的物理页组织成一个**侵入式链表**。每个空闲页的起始位置被强制转换为一个 `struct run` 指针，该结构体只包含一个指向下一个空闲页的 `next` 指针。  这样就无需额外的空间来存储元数据。
* **初始化 (`kinit` & `freerange`)**: 内核初始化时，`kinit` 函数调用 `freerange`。 `freerange` 负责将从内核镜像末尾（由链接器符号 `end` 指定）到物理内存顶端（`0x88000000`）之间的所有内存，逐页地加入到空闲链表中。
* **分配 (`kalloc`)**: 分配一个物理页时，只需从空闲链表的头部取下一个节点，并返回其地址。
* **释放 (`kfree`)**: 释放一个物理页时，将其添加到空闲链表的头部。

### 2. 虚拟内存 (`kernel/vm.c`)

该模块实现了 RISC-V Sv39 三级页表机制。

* **页表遍历 (`walk`)**: 这是页表操作的核心函数。它接收一个根页表的地址和一个虚拟地址，然后根据虚拟地址的高 27 位（分为三级，每级 9 位），逐级遍历页表。如果中间的页表页不存在，它可以根据 `alloc` 参数决定是否使用 `kalloc` 分配一个新的页表页。 最终返回目标虚拟地址对应的最末级页表项（PTE）的地址。
* **地址映射 (`mappages`)**: 该函数用于建立一段虚拟地址到物理地址的映射。它在一个循环中，对指定范围内的每个页面调用 `walk` 函数找到对应的 PTE，然后填入物理地址和权限位（如 `PTE_R`, `PTE_W`, `PTE_X`）。
* **内核页表创建 (`kvminit`)**: 在 `kmain` 中调用，负责创建内核自身的页表。它为几个关键的内存区域建立了映射：
    1.  **UART 设备**: 将物理地址 `0x10000000` 恒等映射，权限为 R/W。
    2.  **内核代码段 (`.text`)**: 从 `0x80000000` 到 `etext`，恒等映射，权限为 R/X（只读、可执行）。
    3.  **内核数据段和剩余内存**: 从 `etext` 到 `PHYSTOP`，恒等映射，权限为 R/W。
* **激活 MMU (`kvminithart`)**: 这是启用虚拟内存的最后一步。它将内核根页表的物理地址写入 `satp` 寄存器，然后执行 `sfence.vma` 指令来清空 TLB ，使新的页表映射生效。

## 实验结果

内核启动后，依次打印物理内存分配器和页表创建的初始化信息。在 `kvminithart` 执行后，内核继续打印成功启用虚拟内存的信息。之后内核保持运行而没有崩溃，这证明了即使在 MMU 开启、CPU 开始使用虚拟地址后，我们建立的页表映射仍然是正确的，内核能够继续访存和执行指令。