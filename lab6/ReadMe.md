# 实验六：系统调用 (System Calls)

## 实验目标

本实验的目标是实现用户态（User Mode）与内核态（Supervisor Mode）之间的交互机制——系统调用。我们将构建核心的系统调用分发框架，实现进程管理和基础 I/O 相关的系统调用，并解决由中断嵌套带来的上下文破坏问题，最终建立一个安全、稳健的内核环境。

## 核心实现

### 1. 系统调用框架

* **陷阱分发 (`kernel/trap.c`)**:
    * 扩展了 `kerneltrap` 函数以处理 `scause = 8`（来自 S-mode 的环境调用）。
    * 注意：由于我们目前的测试代码运行在内核态（S-mode），我们使用 `ecall` 指令模拟系统调用过程。
    * 异常处理后，手动将 `sepc` 增加 4，以跳过 `ecall` 指令，避免无限循环执行同一条指令。

* **参数获取 (`kernel/syscall.c`)**:
    * 实现了 `argint`、`argaddr` 等辅助函数，用于从进程的 Trapframe 中提取系统调用参数（存放在 `a0`-`a5` 寄存器中）。

* **分发器 (`syscall`)**:
    * 根据 `a7` 寄存器中的系统调用号，在函数指针数组 `syscalls[]` 中查找并执行相应的处理函数。
    * 将返回值存回 `a0` 寄存器。

### 2. 核心系统调用实现

* **进程管理 (`kernel/sysproc.c`)**:
    * `sys_fork`: 调用 `fork()` 创建子进程。
    * `sys_exit`: 调用 `exit()` 终止当前进程。
    * `sys_wait`: 调用 `wait()` 等待子进程结束，并将退出状态写入用户提供的地址。
    * `sys_getpid`: 返回当前进程的 PID。

* **文件操作 (`kernel/sysfile.c`)**:
    * `sys_write`: 实现了向文件描述符 `1` (stdout) 和 `2` (stderr) 写入数据的功能，底层调用 `cons_putc` 输出到控制台。

### 3. 关键问题修复：嵌套中断与上下文破坏

在压力测试（Test 13）中，我们发现如果在处理系统调用（开启中断）期间发生了时钟中断，会导致内核崩溃。

* **问题根源**: 
    1. 系统调用进入 `kerneltrap`。
    2. `intr_on()` 开启中断。
    3. 时钟中断发生，硬件自动覆盖了 `sepc`（异常程序计数器）和 `sstatus`（状态寄存器）。
    4. 时钟中断返回后，外层的系统调用处理完毕，准备使用 `sret` 返回。
    5. 此时 `sepc` 和 `sstatus` 已被污染，导致 `sret` 跳转到了错误的地址或使用了错误的特权级，引发 Kernel Panic。

* **解决方案**:
    在 `kerneltrap` 中，在调用 `intr_on()` 之前，将入口时的 `sepc` 和 `sstatus` 值保存到内核栈上的局部变量中。在执行 `sret` 之前，从栈中恢复这些寄存器的正确值。

### 4. 安全性增强

为了防止恶意或错误的程序导致内核崩溃，我们在 `sys_write` 中引入了内存检查机制。

* **地址验证 (`validate_addr`)**: 在访问用户传入的指针之前，遍历该内存范围对应的所有页表项。
* **防御策略**: 如果发现地址未映射或无效（`PTE_V` 为 0），系统调用直接返回 `-1` 错误码，而不是触发 Page Fault 导致内核 Panic。

### 5. 库函数增强

* **`printf`**: 增加了对 `%l` 修饰符（如 `%ld`, `%lu`, `%lx`）的支持，以便正确打印 64 位整数。

## 编译与运行

```bash
# 编译并启动 QEMU
make run