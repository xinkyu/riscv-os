# 实验一：RISC-V 引导与裸机启动

## 实验目标

本实验的目标是搭建一个最基础的操作系统内核框架，使其能够在 QEMU 模拟的 RISC-V `virt` 机器上启动，并最终通过串口输出 "Hello OS!"。 这标志着我们成功地在裸机上运行了自己编写的代码。

## 核心实现步骤

### 1. 启动汇编 (`kernel/entry.S`)

CPU 加电后执行的第一段代码。它的主要职责是为 C 语言代码建立一个有效的执行环境。
* **设置栈指针 (`sp`)**: C 语言函数的调用依赖于栈。这里我们预留了 4KB 的栈空间，并将 `sp` 指向栈顶 `stack_top`。
* **清零 BSS 段**: 根据 C 语言标准，未初始化的全局变量和静态变量默认值为 0。 BSS 段在可执行文件中不占空间，因此需要启动代码手动将其清零。 我们通过链接脚本提供的 `__bss_start` 和 `__bss_end` 符号来定位 BSS 段的范围。
* **跳转到 C 入口**: 环境准备好后，使用 `call kmain` 指令将控制权交给 C 语言的主函数。

### 2. 链接器脚本 (`kernel/kernel.ld`)

该文件指导链接器（`ld`）如何组织编译后的代码和数据，生成最终的 `kernel.elf` 可执行文件。
* **入口点**: `ENTRY(_start)` 指定了程序的入口符号，即 `entry.S` 中的 `_start` 标签。
* **基地址**: `BASE_ADDRESS = 0x80000000` 定义了内核被加载到内存的起始物理地址。
* **段（SECTIONS）定义**: 规定了代码段 (`.text`)、只读数据段 (`.rodata`)、已初始化数据段 (`.data`) 和 BSS 段 (`.bss`) 的排列顺序。

### 3. 串口驱动 (`kernel/uart.c`)

实现了一个简单的、基于轮询的 UART 驱动，用于向 QEMU 的串口发送字符。
* **内存映射 I/O**: QEMU `virt` 机器的 UART 设备被映射到物理地址 `0x10000000L`。
* **发送字符**: `uart_putc` 函数通过一个循环来检查线路状态寄存器（LSR）的 `THRE` 位，等待发送保持寄存器（THR）为空。 一旦为空，就将字符写入 `THR` 完成发送。

### 4. 主函数 (`kernel/main.c`)

作为 C 代码的入口，`kmain` 函数调用 `uart_puts("Hello OS!\n")` 来打印目标字符串，然后进入一个死循环，防止 CPU "跑飞"。

## 实验结果

执行 `make run` 后，QEMU 启动，并在终端上成功打印出 "Hello OS!"，表明整个引导流程和串口驱动工作正常。