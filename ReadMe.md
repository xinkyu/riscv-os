# 从零构建操作系统

本专案是武汉大学《操作系统实践A》课程的成果。
目标是从零开始，基于 RISC-V 架构，逐步实现一个迷你的操作系统核心。

## 目前完成进度

* **实验 1**: RISC-V 引导与裸机启动
    * 实现了基本的汇编语言启动程序。
    * 建立了 C 语言执行环境并设置了堆栈。
    * 实现了简化的 UART 驱动，可在 QEMU 中输出 "Hello OS"。
* **实验 2**: 内核 printf 与清屏功能实现
    * 实现了支持 `%d`、`%x`、`%s`、`%c`、`%%` 的 `printf` 函数。
    * 实现了基于 ANSI 转义序列的清屏功能。
* **实验 3**: 页表与内存管理
    * 实现了一个页式物理内存分配器 (`kalloc.c`)。
    * 实现了 RISC-V Sv39 页表管理机制，包括页表的创建和地址映射 (`vm.c`)。
    * 成功激活了 MMU，使内核在虚拟内存环境下稳定运行。
* **实验 4**: 中断处理与时钟管理
    * 实现了 Supervisor 模式下的中断入口 (`kernelvec.S`)，用于保存和恢复上下文。
    * 建立了 C 语言中断处理框架 (`trap.c`)，能够根据 `scause` 寄存器分发中断和异常。
    * 成功初始化并启用了时钟中断，内核现在可以周期性地响应硬件定时器事件。
* **实验 5**: 进程管理与调度
    * 实现了进程控制块 (`struct proc`) 和进程表。
    * 实现了汇编级的上下文切换函数 `swtch`。
    * 实现了基于时钟中断的抢占式轮转（Round-Robin）调度器。
    * 实现了 `sleep`/`wakeup` 同步原语。
* **实验 6**: 系统调用 (System Calls)
    * 建立了 `ecall` 陷阱处理机制，内核现在可以响应 `scause == 8` 异常。
    * 实现了 `syscall` 分发器和 `syscalls` 函数指针数组。
    * 添加了 `sys_getpid` 作为第一个系统调用实现，并成功通过内核态测试。
    * 修复了 `printf` 重入和调度器启动时的多个关键并发/死锁 Bug，使内核调度更加稳定。

## 开发环境

* **操作系统**: Ubuntu 22.04 LTS 
* **工具链**: riscv64-unknown-elf-gcc 
* **模拟器**: QEMU (qemu-system-riscv64) 

## 编译与执行

1.  **编译内核**：
    ```bash
    make
    ```

2.  **在 QEMU 中执行**：
    ```bash
    make run
    ```